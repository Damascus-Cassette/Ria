from pydantic import BaseModel
from contextvars import ContextVar
from contextlib import contextmanager
from typing import Self, Any



class exec_socket(BaseModel):
    ''' Loose exec_socket type '''
    name       : str
    
    is_address : bool
    address    : str|None
    
    value      : Any|BaseModel

class exec_node(BaseModel):
    ''' Execution Node, Generated by Meta Node and contains method to execute action '''
    ###### DATA STRUCT ######

    #### Node Definition Immutable ####
    #Required on child class (TODO: Enforce)
    Identifier    : str
    Version       : str
    Cachable      : bool
    Disc_Cachable : bool    #if the Execution cache can be written to disc & shared to other instances
    Deterministic : bool    #If false, Cachable and Disc_Cachable are not utilized

    #### Node Definition Mutable ####

    #DEFERED: Later versions may have a constructed type struct for struct checking
    in_sockets   : list[exec_socket]
    out_sockets  : list[exec_socket]
    context_vars : list[exec_socket]    #Another version of in_sockets that were fullfulled exclusivly contextually.


    #### Node Instance Info ####
    meta_uuid          : str            # UUID of generating meta_id 
    exec_uuid          : str            # If chain_deterministic use context_hash. Else true random UUID
    chain_determinisic : bool           # If all(inputs.deterministic), if true allows context_hash to be used to grab cached values. Elif self.Cachable, check value_hash in cache
    _context_hash      : str            # Recorded Form for cached versions
    _value_hash        : str            # Recorded Form for cached versions
    
    #### Properties ####
    @property
    def context_hash(self):
        ''' if not already calculated, Calculate context hash from id, version, value & reference inputs, store as _context_hash '''
    @property
    def value_hash(self):
        ''' if not already calculated, Calculate context hash from id, version, value & executed inputs, store as _value_hash '''
        ''' Raise if not all inputs have been calculated '''
    @property
    def state_hash(self):
        ''' Calculate state of all known values with context of unknown inputs ''' #Future possible optimziation of piecemealing input cache

    ###### EXECUTION & INTERACTION ###### 

    #### Space Generation ####

    @contextmanager
    def generate_view(self,bring_in:list|dict|None=None): ...        
    @contextmanager
    def generate_import(self,bring_in:list|dict|None=None): ...
    @contextmanager
    def generate_export(self,bring_in:list|dict|None=None): ...
        # Generate a space, yield it's filepath, edit output filepaths to be relative.
        # Incoming may be absolute paths or space relative relative
        # Will need database_io from context (user, session, machine-id in database_io instance)

    #### Execution ####

    def _execute(self):
        if self.Cachable and self.chain_determinisic:
            if res := session.get().cache.retrieve(self.context_hash):
                data   = res[0]
                folder = res[1]
                self.localize_cache(data, folder)

        self.execute_inputs()

        if self.Cachable:
            if res := session.get().cache.retrieve(self.value_hash):
                data   = res[0]
                folder = res[1]
                self.localize_cache(data, folder)
                
        self.execute()

        if self.Cachable:
            session.get().cache.add(self) 
                #Stores caches in memory and on disc w/a
                #this will export via pydantic with accomidations for custom data types.
                #Consider allowing for memory dumping if on disc.

            # session.get().cache[self.value_hash] = self
            # if self.chain_determinisic:
            #     session.get().cache[self.context_hash] = self
            # if self.Disc_Cachable:
            #     self.store_disc_cache #TODO: Determine cache location.
            

    def localize_cache(self,cache_item:Self):
        ''' Will depend on self.execution method & how that is stored '''
        raise Exception('load_cache method is undefined!')
    
    def execute(self):
        ''' Will depend on self.execution method & how that is stored '''
        raise Exception('execute method is undefined!')



class _exec_node_examples:
    class compute(exec_node):
        Identifier    = 'integer_compute'
        Version       = 1.0
        Cachable      = True
        Disc_Cachable = True
        Deterministic = True 

        def execute(self):
            self.out_socket['A'].value = self.inputs['A'].value * self.inputs['B']
        
        def load_cache(self,cache:Self):
            self.out_socket['A'] = cache.out_socket['A']

    class compute_ondisc(exec_node):
        Identifier    = 'compute_to_disc'
        Version       = 1.0
        Cachable      = True
        Disc_Cachable = True
        Deterministic = True 

        def execute(self):
            with self.generate_view() as out_path:
                write(out_path,'text.txt',string=self.in_sockets['A'])
        
        def load_cache(self,cache:Self):
            self.out_socket['A'] = cache.out_socket['A']

    class generate_function(exec_node):
        Identifier    = 'generate_function'
        Version       = 1.0
        Cachable      = True
        Disc_Cachable = False
        Deterministic = True 
        
        def execute(self):
            def function(later_argument:int):
                return later_argument * self.in_socket['A']
            self.out_socket['A'] = function

    class random_value(exec_node):
        ''' Will be re-run every use of it as it's never cached. '''
        Identifier    = 'true_random_value'
        Version       = 1.0
        Cachable      = False
        Disc_Cachable = False
        Deterministic = False
        
        def execute(self):
            range_low  = self.in_socket['A']
            range_high = self.in_socket['b']
            self.out_sockets['A'] = random.random(range_low, range_high)
                
    class phseduo_random_value(exec_node):
        ''' Semi-Deterministic random value, could be random per session, node or manually input seed. '''
        ''' Still requires execution once. Context inputs must require session as an input for the type to be accomidated properly in context '''
        ''' The assumption is also that the whole context object's state is required, may have to change to allow sub-attributes? '''

        Identifier    = 'seeded_random_value'
        Version       = 1.0
        Cachable      = True
        Disc_Cachable = True
        Deterministic = True

        def execute(self):
            session_uuid = self.context_vars['Session'].UUID
            self.out_sockets['A'] = random.random(0,100, seed = session_uuid)

    def context_random_value(exec_node):
        ''' Example of pseduo random value listening to more constrained context value, a socket result '''
        
        Identifier    = 'seeded_random_value'
        Version       = 1.0
        Cachable      = True
        Disc_Cachable = True
        Deterministic = True

        def _in_downstream_meta_node(self,context,):
            ...
            context.geometry.set(self.input_sockets['Geometry_Socket']) # Reference to a socket on this node, or other object
            self.compile_inputs(context)                                # Compilation called for inputs, such as this node
            ...

        def _in_my_meta_node(self,context):
            exec_node = self.base()
            ... #Add sockets
            exec_node.context_vars['geometry'].address = context.geometry.get().get_address()
                #Hash and so forth inherit from reference?
                #chain_deterministic accounts for the reference as well (as it's another input technically)

        def execute(self):
            session_uuid = self.context_vars['geometry'].value
            self.out_sockets['A'] = random.random(0,100, seed = session_uuid)
        